1.let  const
   没有变量提升  
   同一作用域内，无法对同一个变量/常量进行重复声明。
     const 块级作用域  可以修改引用数据类型不能修改基础数据类型

2.什么是作用域链 
  函数执行时，现在内部找这个变量如果找不到向上层找直到找到全局作用域或者undefined


3.作用域
   指一个变量的作用范围
   在ES6之前，只有全局作用域和函数作用域，在ES6中，新增了块级作用域

4.结构赋值
    数组：解构时不能用字符串，通过下标来结构
    对象：按照属性来解构，可以更换属性名

5.普通函数和箭头函数的区别
    普通函数的this 总是指向调用它的对象,如果用作构造函数，它指向创建的对象实例
    箭头函数全都是匿名函数
    箭头函数没有this指向和arguments伪数组,箭头函数不具有 prototype 原型对象
       

6.模板字符串
   用反引号(`)标识它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量
     底层远离还是字符串

7.symbol
    1.Symbol的值是唯一的,用来解决命名冲突的问题
    2.Symbol值不能和其他数据进行运算
    3.Symbol定义的对象属性不能使用for..in循环遍历,但是可以使用Reflect.ownkeys来获取对象的所有键名


8.遍历器
    是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 teuator 接口，就可以完成遍历操作(即依次处理该数据结构的所有成员


9. promise
   1.概念:promise函数是解决异步变成问题产生的,所谓promise,简单说就是一个容器,里面保存着某个未来才会结束的事件(通常是一个异步操作) 的结果。从语法上说,promise 是一个对象,从他可以获取异步操作的消息。promise 提供唯一的 API， 各种一步操作都可以用同样的方法进行处理。
   2.实例化promise函数，也是一个容器，既不是同步,也不是异步，里面存放着异步代码
     3.两个参数  resolve: 成功返回  reject; 失败返回  .then()成功返回   .catch()失败的返回
  (特点)
   1.对象的状态不受外界影响,有三种状态: pending (进行中)、fulfilled (已成功)和 rejected (已失败)
   2.一旦状态改变,就不会再变,任何时候都可以得到这个结果.
   3.`Promise`对象的状态改变，只有两种可能:从 pending 变为 fulfilLed 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved (已定型)。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

10.数组的合并
    1.可以使用循环加push方法
    2.可以使用concat方法   语法  let [新数组] = [老数组].concat([另外的一个数组])


11.  ...扩展运算符
     1.概念: ... 扩展运算符能将[数组] 转换为逗号分隔的[参数序列]